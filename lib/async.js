// Generated by CoffeeScript 1.7.1
(function() {
  var async, defaultFinalCb, _argumentsToArray;

  _argumentsToArray = function() {
    var arg, ret, _i, _len;
    ret = [];
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      arg = arguments[_i];
      ret.push(arg);
    }
    return ret;
  };

  async = {};

  defaultFinalCb = function(err, result) {
    if (arguments.length === 1) {
      result = err;
      err = null;
    }
    if (err) {
      return err;
    } else {
      return result;
    }
  };

  async.some = function(arr, asyncFunc, finalCb) {
    if (!finalCb) {
      finalCb = defaultFinalCb;
    }
    if (arr.length === 0) {
      return finalCb(false);
    } else {
      return asyncFunc(arr[0], function(err, resp) {
        if (arguments.length === 1) {
          resp = err;
          err = null;
        }
        if (err) {
          return finalCb(err, null);
        }
        if (!!resp) {
          return finalCb(!!resp);
        } else {
          return async.some(arr.slice(1), asyncFunc, finalCb);
        }
      });
    }
  };

  async.every = function(arr, asyncFunc, finalCb) {
    if (!finalCb) {
      finalCb = defaultFinalCb;
    }
    if (arr.length === 0) {
      return finalCb(true);
    } else {
      return asyncFunc(arr[0], function(err, resp) {
        if (arguments.length === 1) {
          resp = err;
          err = null;
        }
        if (err) {
          return finalCb(err, null);
        }
        if (!resp) {
          return finalCb(!!resp);
        } else {
          return async.every(arr.slice(1), asyncFunc, finalCb);
        }
      });
    }
  };

  async.map = function(arr, asyncFunc, finalCb, asyncArr) {
    if (asyncArr == null) {
      asyncArr = [];
    }
    if (!finalCb) {
      finalCb = defaultFinalCb;
    }
    if (arr.length === 0) {
      return finalCb(null, asyncArr);
    } else {
      return asyncFunc(arr[0], function(err, resp) {
        if (arguments.length === 1) {
          resp = err;
          err = null;
        }
        if (err) {
          return finalCb(err, null);
        }
        asyncArr.push(resp);
        return async.map(arr.slice(1), asyncFunc, finalCb, asyncArr);
      });
    }
  };

  async.filter = function(arr, asyncFunc, finalCb, asyncArr) {
    if (asyncArr == null) {
      asyncArr = [];
    }
    if (!finalCb) {
      finalCb = defaultFinalCb;
    }
    if (arr.length === 0) {
      return finalCb(null, asyncArr);
    } else {
      return asyncFunc(arr[0], function(err, resp) {
        if (arguments.length === 1) {
          resp = err;
          err = null;
        }
        if (err) {
          return finalCb(err, null);
        }
        if (!!resp) {
          asyncArr.push(arr[0]);
        }
        return async.filter(arr.slice(1), asyncFunc, finalCb, asyncArr);
      });
    }
  };

  async.reduce = function(arr, asyncFunc, acum, finalCb) {
    if (acum == null) {
      acum = 0;
    }
    if (!finalCb) {
      finalCb = defaultFinalCb;
    }
    if (arr.length === 0) {
      return finalCb(null, acum);
    } else {
      return asyncFunc(acum, arr[0], function(err, resp) {
        if (arguments.length === 1) {
          resp = err;
          err = null;
        }
        if (err) {
          return finalCb(err, null);
        }
        acum = resp;
        return async.reduce(arr.slice(1), asyncFunc, acum, finalCb);
      });
    }
  };

  async.waterfall = function(funcArr, finalCb, args) {
    var cb;
    if (args == null) {
      args = null;
    }
    if (!finalCb) {
      finalCb = defaultFinalCb;
    }
    cb = function(err, args) {
      if (arguments.length === 1) {
        args = err;
        err = null;
      }
      if (err) {
        return finalCb(err, null);
      } else {
        return async.waterfall(funcArr.slice(1), finalCb, args);
      }
    };
    if (funcArr.length === 0) {
      return finalCb(null, args);
    } else {
      return funcArr[0](args, cb);
    }
  };

  async.series = function(funcArr, finalCb, results) {
    var cb;
    if (results == null) {
      results = [];
    }
    if (!finalCb) {
      finalCb = defaultFinalCb;
    }
    cb = function(err, args) {
      if (arguments.length === 1) {
        args = err;
        err = null;
      }
      if (err) {
        return finalCb(err, results);
      } else {
        results.push(args);
        return async.series(funcArr.slice(1), finalCb, results);
      }
    };
    if (funcArr.length === 0) {
      return finalCb(null, results);
    } else {
      return funcArr[0](cb);
    }
  };

  async.parallel = function(funcArr, finalCb) {
    var completed, fn, index, len, make_parallel_cb, results, _i, _len;
    if (!finalCb) {
      finalCb = defaultFinalCb;
    }
    completed = 0;
    len = funcArr.length;
    results = new Array(len);
    make_parallel_cb = function(index) {
      return function(err, args) {
        if (arguments.length === 1) {
          args = err;
          err = null;
        }
        if (err) {
          return finalCb(err, results);
        } else {
          results[index] = args;
          completed += 1;
          if (completed === len) {
            return finalCb(null, results);
          }
        }
      };
    };
    for (index = _i = 0, _len = funcArr.length; _i < _len; index = ++_i) {
      fn = funcArr[index];
      fn(make_parallel_cb(index));
    }
    return void 0;
  };

  module.exports = async;

}).call(this);
