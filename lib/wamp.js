// Generated by CoffeeScript 1.7.1
(function() {
  var MAX_ID, MESSAGE_TYPES, TRANSPORT_TYPES, WampClient, WampPeer, WampRouter, createWampRouter, defer, e, events, genId, isValidURI, net, randomNum, test, util, ws,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  events = require('events');

  util = require('util');

  net = require('net');

  ws = require('./ws');

  defer = require('./promises').defer;

  try {
    defer = require('./promises.litcoffee').defer;
  } catch (_error) {
    e = _error;
    defer = require('./promises').defer;
  }

  MESSAGE_TYPES = {
    HELLO: 1,
    WELCOME: 2,
    ABORT: 3,
    CHALLENGE: 4,
    AUTHENTICATE: 5,
    GOODBYE: 6,
    HEARTBEAT: 7,
    ERROR: 8,
    PUBLISH: 16,
    PUBLISHED: 17,
    SUBSCRIBE: 32,
    SUBSCRIBED: 33,
    UNSUBSCRIBE: 34,
    UNSUBSCRIBED: 35,
    EVENT: 36,
    CALL: 48,
    CANCEL: 49,
    RESULT: 50,
    REGISTER: 64,
    REGISTERED: 65,
    UNREGISTER: 66,
    UNREGISTERED: 67,
    INVOCATION: 68,
    INTERRUPT: 69,
    YIELD: 70
  };

  TRANSPORT_TYPES = {
    DIRECT: 1,
    WEBSOCKET: 2,
    UNIXSOCKET: 3
  };

  MAX_ID = Math.pow(2, 53);

  isValidURI = function(uri_string) {
    return !!uri_string.match(/^(([0-9a-z_]{2,}\.)|\.)*([0-9a-z_]{2,})?$/);
  };

  randomNum = function(len) {
    var n;
    return parseInt(((function() {
      var _i, _results;
      _results = [];
      for (n = _i = 1; 1 <= len ? _i <= len : _i >= len; n = 1 <= len ? ++_i : --_i) {
        _results.push((Math.floor(Math.random() * 10)).toString());
      }
      return _results;
    })()).join(''));
  };

  genId = function() {
    return randomNum(15);
  };


  /*
  class WampSession extends events.EventEmitter
    constructor: (@id, options) ->
      @_options = options or {}
      for key, val of @_options
        @[key] = val
      @nextId = 1
   */

  WampPeer = (function(_super) {
    "Peer at one end of Wamp Session. Involves acting as a session itself, as well";
    __extends(WampPeer, _super);

    function WampPeer(parent, transport, roles, options) {
      this.parent = parent;
      this.transport = transport;
      this.roles = roles;
      this.processMessage = __bind(this.processMessage, this);
      this.sendMessage = __bind(this.sendMessage, this);
      this.cleanUp = __bind(this.cleanUp, this);
      this.setOptions = __bind(this.setOptions, this);
      this.isOpen = true;
      this.transport.on('close', (function(_this) {
        return function(code) {
          _this.isOpen = false;
          _this.cleanUp();
          return console.log("Closing WampPeer due to transport closed.");
        };
      })(this));
      this.id = null;
      this.nextId = 1;
      this.setOptions(options);
    }

    WampPeer.prototype.setOptions = function(options) {
      var key, val, _ref, _results;
      this._options = options || {};
      _ref = this._options;
      _results = [];
      for (key in _ref) {
        val = _ref[key];
        _results.push(this[key] = val);
      }
      return _results;
    };

    WampPeer.prototype.cleanUp = function() {
      var index, invocation, invocations, key, proc, registered, session, sessions, subscription, subscriptions, topic, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _results;
      registered = (_ref = this.parent.realms) != null ? _ref[this.realm].registered_procedures : void 0;
      if (registered) {
        for (index = _i = 0, _len = registered.length; _i < _len; index = ++_i) {
          proc = registered[index];
          try {
            if (proc.sessionId === this.id) {
              this.parent.realms[this.realm].registered_procedures.splice(index, 1);
            }
          } catch (_error) {
            e = _error;
            console.log("ERROR: " + e.message);
          }
        }
      }
      invocations = (_ref1 = this.parent.realms) != null ? _ref1[this.realm].invocations : void 0;
      if (invocations) {
        for (index = _j = 0, _len1 = invocations.length; _j < _len1; index = ++_j) {
          invocation = invocations[index];
          try {
            if (invocation.sessionId === this.id) {
              this.parent.realms[this.realm].invocations.splice(index, 1);
            }
          } catch (_error) {
            e = _error;
            console.log("ERROR: " + e.message);
          }
        }
      }
      subscriptions = (_ref2 = this.parent.realms) != null ? _ref2[this.realm].subscriptions : void 0;
      if (subscriptions) {
        for (key in subscriptions) {
          topic = subscriptions[key];
          try {
            for (index = _k = 0, _len2 = topic.length; _k < _len2; index = ++_k) {
              subscription = topic[index];
              if (subscription.sessionId === this.id) {
                topic.splice(index, 1);
              }
            }
          } catch (_error) {
            e = _error;
            console.log("ERROR: " + e.message);
          }
        }
      }
      sessions = (_ref3 = this.parent.realms) != null ? _ref3[this.realm].sessions : void 0;
      if (sessions) {
        _results = [];
        for (index = _l = 0, _len3 = sessions.length; _l < _len3; index = ++_l) {
          session = sessions[index];
          try {
            if (session.id === this.id) {
              this.parent.realms[this.realm].sessions.splice(index, 1);
              break;
            } else {
              _results.push(void 0);
            }
          } catch (_error) {
            e = _error;
            _results.push(console.log("ERROR: " + e.message));
          }
        }
        return _results;
      }
    };

    WampPeer.prototype.sendMessage = function(message) {
      if (this.parent.constructor.name === "WampClient") {
        console.log(this.parent.constructor.name, "sends a message:", JSON.stringify(message));
        console.log("Open condition is:", this.isOpen);
        console.log("WebSocket state is: %s", this.transport.readyState);
      }
      if (this.isOpen) {
        return this.transport.send(message);
      }
    };

    WampPeer.prototype.processMessage = function(message) {
      var ArgumentsKwDict, ArgumentsList, OptionsDict, ProcedureUri, PublicationId, RegistrationId, RequestId, SubscriptionId, TopicUri, arr, callee_session, callee_sessionId, caller_session, caller_sessionId, code, details, index, invocation, invocation_message, key, msgArray, proc, procedure, realm, registrationId, resp, result_message, session, sid, subscription, suscription, topic, _base, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _m, _n, _o, _p, _q, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      if (!this.isOpen) {
        return;
      }
      arr = JSON.parse(message);
      code = arr[0];
      if (code !== MESSAGE_TYPES.HELLO && code !== MESSAGE_TYPES.WELCOME) {
        if (!this.id) {
          return;
        }
      }
      switch (code) {
        case MESSAGE_TYPES.HELLO:
          console.log("Router received HELLO message");
          _ref = arr.slice(1), realm = _ref[0], details = _ref[1];
          this.id = this.parent.nextSessionId;
          this.realm = realm;
          this.setOptions(details);
          if (!(realm in this.parent.realms)) {
            this.parent.realms[realm] = {
              sessions: [],
              registered_procedures: [],
              invocations: [],
              subscriptions: {}
            };
          }
          this.parent.realms[realm].sessions.push(this);
          console.log("@realms[" + realm + "].sessions.length: %d", this.parent.realms[realm].sessions.length);
          this.sendMessage(JSON.stringify([
            MESSAGE_TYPES.WELCOME, this.parent.nextSessionId, {
              roles: this.roles
            }
          ]));
          console.log("Router sent WELCOME message to " + this.parent.nextSessionId);
          return this.parent.nextSessionId += 1;
        case MESSAGE_TYPES.WELCOME:
          console.log("Client Received Welcome Message");
          _ref1 = arr.slice(1), sid = _ref1[0], details = _ref1[1];
          this.id = sid;
          this.routerRoles = details;
          this.realm = this.parent.realm;
          this.subscriptions = [];
          this.registrations = [];
          return typeof (_base = this.parent).onopen === "function" ? _base.onopen({
            id: this.id,
            realm: this.realm,
            roles: this.roles,
            routerRoles: this.routerRoles,
            subscriptions: this.subscriptions,
            registrations: this.registrations
          }) : void 0;
        case MESSAGE_TYPES.ABORT:
          return console.log("Received Abort Message");
        case MESSAGE_TYPES.CHALLENGE:
          return console.log("Received Challenge Message");
        case MESSAGE_TYPES.AUTHENTICATE:
          return console.log("Received Authenticate Message");
        case MESSAGE_TYPES.GOODBYE:
          console.log("Received GoodBye Message");
          this.sendMessage(message);
          this.cleanUp();
          return this.transport.close();
        case MESSAGE_TYPES.HEARTBEAT:
          return console.log("Received HeartBeat Message");
        case MESSAGE_TYPES.PUBLISH:
          _ref2 = arr.slice(1), RequestId = _ref2[0], OptionsDict = _ref2[1], TopicUri = _ref2[2], ArgumentsList = _ref2[3], ArgumentsKwDict = _ref2[4];
          PublicationId = this.nextId;
          this.nextId += 1;
          topic = this.parent.realms[this.realm].subscriptions[TopicUri];
          if (topic) {
            for (_i = 0, _len = topic.length; _i < _len; _i++) {
              suscription = topic[_i];
              _ref3 = this.parent.realms[this.realm].sessions;
              for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
                session = _ref3[_j];
                if (session.id === suscription.sessionId) {
                  msgArray = [MESSAGE_TYPES.EVENT, suscription.SubscriptionId, PublicationId, OptionsDict];
                  if (ArgumentsList) {
                    msgArray.push(ArgumentsList);
                  }
                  if (ArgumentsKwDict) {
                    msgArray.push(ArgumentsKwDict);
                  }
                  session.sendMessage(JSON.stringify(msgArray));
                  break;
                }
              }
            }
          }
          if (OptionsDict.acknowledge) {
            return this.sendMessage(JSON.stringify([MESSAGE_TYPES.PUBLISHED, RequestId, PublicationId]));
          }
          break;
        case MESSAGE_TYPES.PUBLISHED:
          return console.log("Received Published Message");
        case MESSAGE_TYPES.SUBSCRIBE:
          console.log("Received subscribe message from session " + this.id);
          _ref4 = arr.slice(1), RequestId = _ref4[0], OptionsDict = _ref4[1], TopicUri = _ref4[2];
          SubscriptionId = this.nextId;
          this.nextId += 1;
          if (!this.parent.realms[this.realm].subscriptions[TopicUri]) {
            this.parent.realms[this.realm].subscriptions[TopicUri] = [];
          }
          this.parent.realms[this.realm].subscriptions[TopicUri].push({
            sessionId: this.id,
            SubscriptionId: SubscriptionId,
            OptionsDict: OptionsDict
          });
          resp = [MESSAGE_TYPES.SUBSCRIBED, RequestId, SubscriptionId];
          this.sendMessage(JSON.stringify(resp));
          return console.log("Registered subscription for " + TopicUri + " in realm " + this.realm);
        case MESSAGE_TYPES.SUBSCRIBED:
          return console.log("Received Subscribed Message");
        case MESSAGE_TYPES.UNSUBSCRIBE:
          _ref5 = arr.slice(1), RequestId = _ref5[0], SubscriptionId = _ref5[1];
          console.log("Received unsubscribe message from session " + this.id + " with requestId: " + RequestId + " and subscriptionId: " + SubscriptionId);
          _ref6 = this.parent.realms[this.realm].subscriptions;
          for (key in _ref6) {
            topic = _ref6[key];
            for (index = _k = 0, _len2 = topic.length; _k < _len2; index = ++_k) {
              subscription = topic[index];
              if ((subscription.SubscriptionId === SubscriptionId) && (subscription.sessionId === this.id)) {
                console.log("Found subscription to erase at index " + index + ". Going to do it for request: " + RequestId);
                topic.splice(index, 1);
                return this.sendMessage(JSON.stringify([MESSAGE_TYPES.UNSUBSCRIBED, RequestId]));
              }
            }
          }
          console.log("Did not find a subscription to erase. Sending error message: 'wamp.error.no_such_subscription'");
          return this.sendMessage(JSON.stringify([MESSAGE_TYPES.ERROR, MESSAGE_TYPES.UNSUBSCRIBE, RequestId, {}, "wamp.error.no_such_subscription"]));
        case MESSAGE_TYPES.UNSUBSCRIBED:
          return console.log("Received Unsubscribed Message");
        case MESSAGE_TYPES.EVENT:
          return console.log("Received Event Message");
        case MESSAGE_TYPES.CALL:
          _ref7 = arr.slice(1), RequestId = _ref7[0], OptionsDict = _ref7[1], ProcedureUri = _ref7[2], ArgumentsList = _ref7[3], ArgumentsKwDict = _ref7[4];
          _ref8 = this.parent.realms[this.realm].registered_procedures;
          for (_l = 0, _len3 = _ref8.length; _l < _len3; _l++) {
            proc = _ref8[_l];
            if (proc.ProcedureUri === ProcedureUri) {
              callee_sessionId = proc.sessionId;
              registrationId = proc.RegistrationId;
              _ref9 = this.parent.realms[this.realm].sessions;
              for (_m = 0, _len4 = _ref9.length; _m < _len4; _m++) {
                session = _ref9[_m];
                if (session.id === callee_sessionId) {
                  callee_session = session;
                  invocation_message = [MESSAGE_TYPES.INVOCATION, RequestId, registrationId, OptionsDict, ArgumentsList || [], ArgumentsKwDict || {}];
                  this.parent.realms[this.realm].invocations.push({
                    sessionId: this.id,
                    requestId: RequestId
                  });
                  return callee_session.sendMessage(JSON.stringify(invocation_message));
                }
              }
            }
          }
          break;
        case MESSAGE_TYPES.CANCEL:
          return console.log("Received Cancel Message");
        case MESSAGE_TYPES.RESULT:
          return console.log("Received Result Message");
        case MESSAGE_TYPES.REGISTER:
          console.log("Received register message from session " + this.id);
          _ref10 = arr.slice(1), RequestId = _ref10[0], OptionsDict = _ref10[1], ProcedureUri = _ref10[2];
          _ref11 = this.parent.realms[this.realm].registered_procedures;
          for (_n = 0, _len5 = _ref11.length; _n < _len5; _n++) {
            procedure = _ref11[_n];
            if (procedure.ProcedureUri === ProcedureUri) {
              console.log("ERROR: procedure " + ProcedureUri + " already registered.");
              return this.sendMessage(JSON.stringify([MESSAGE_TYPES.ERROR, MESSAGE_TYPES.REGISTER, RequestId, {}, 'wamp.error.procedure_already_exists']));
            }
          }
          RegistrationId = this.nextId;
          this.nextId += 1;
          this.parent.realms[this.realm].registered_procedures.push({
            sessionId: this.id,
            RegistrationId: RegistrationId,
            OptionsDict: OptionsDict,
            ProcedureUri: ProcedureUri
          });
          resp = [MESSAGE_TYPES.REGISTERED, RequestId, RegistrationId];
          this.sendMessage(JSON.stringify(resp));
          return console.log("Registered procedure " + ProcedureUri + " in realm " + this.realm);
        case MESSAGE_TYPES.REGISTERED:
          return console.log("Received Registered Message");
        case MESSAGE_TYPES.UNREGISTER:
          console.log("Received Unregister Message");
          _ref12 = arr.slice(1), RequestId = _ref12[0], RegistrationId = _ref12[1];
          _ref13 = this.parent.realms[this.realm].registered_procedures;
          for (index = _o = 0, _len6 = _ref13.length; _o < _len6; index = ++_o) {
            procedure = _ref13[index];
            if (procedure.RegistrationId === RegistrationId) {
              this.parent.realms[this.realm].registered_procedures.splice(index, 1);
              return this.sendMessage(JSON.stringify([MESSAGE_TYPES.UNREGISTERED, RequestId]));
            }
          }
          return this.sendMessage(JSON.stringify([MESSAGE_TYPES.ERROR, MESSAGE_TYPES.UNREGISTER, RequestId, {}, 'wamp.error.no_such_registration']));
        case MESSAGE_TYPES.UNREGISTERED:
          return console.log("Received Unregistered Message");
        case MESSAGE_TYPES.INVOCATION:
          return console.log("Received Invocation Message");
        case MESSAGE_TYPES.INTERRUPT:
          return console.log("Received Interrupt Message");
        case MESSAGE_TYPES.YIELD:
          _ref14 = arr.slice(1), RequestId = _ref14[0], OptionsDict = _ref14[1], ArgumentsList = _ref14[2], ArgumentsKwDict = _ref14[3];
          _ref15 = this.parent.realms[this.realm].invocations;
          for (_p = 0, _len7 = _ref15.length; _p < _len7; _p++) {
            invocation = _ref15[_p];
            if (invocation.requestId === RequestId) {
              caller_sessionId = invocation.sessionId;
              _ref16 = this.parent.realms[this.realm].sessions;
              for (_q = 0, _len8 = _ref16.length; _q < _len8; _q++) {
                session = _ref16[_q];
                if (session.id === caller_sessionId) {
                  caller_session = session;
                  result_message = [MESSAGE_TYPES.RESULT, RequestId, OptionsDict, ArgumentsList || [], ArgumentsKwDict || {}];
                  return caller_session.sendMessage(JSON.stringify(result_message));
                }
              }
            }
          }
          break;
        default:
          return console.log("Unknown code received.");
      }
    };

    return WampPeer;

  })(events.EventEmitter);

  WampClient = (function(_super) {
    __extends(WampClient, _super);

    function WampClient(options) {
      this.connect = __bind(this.connect, this);
      var key, value;
      if ((!(options != null ? options.url : void 0)) || (!(options != null ? options.realm : void 0))) {
        throw new Error("Must provide a url and a realm to connect to");
      }
      for (key in options) {
        value = options[key];
        this[key] = value;
      }
      this.roles = this.roles || {
        subscriber: {},
        publisher: {},
        callee: {},
        caller: {}
      };
      this.websocket = new ws.WebSocketClientConnection(this.url);
    }

    WampClient.prototype.connect = function() {
      if (this.websocket.readyState !== 'open') {
        return false;
      }
      this.peer = new WampPeer(this, this.websocket, this.roles);
      this.websocket.on('data', (function(_this) {
        return function(opcode, data) {
          return _this.peer.processMessage(data);
        };
      })(this));
      this.peer.sendMessage(JSON.stringify([MESSAGE_TYPES.HELLO, this.realm, this.roles]));
      return true;
    };

    return WampClient;

  })(events.EventEmitter);

  WampRouter = (function(_super) {
    __extends(WampRouter, _super);

    WampRouter.prototype._webSocketHandler = function(websocket) {
      websocket.peer = new WampPeer(this, websocket, this.roles);
      websocket.on('open', (function(_this) {
        return function() {
          return console.log("WebSocket opened");
        };
      })(this));
      websocket.on('data', (function(_this) {
        return function(opcode, data) {
          return websocket.peer.processMessage(data);
        };
      })(this));
      return websocket.on('close', (function(_this) {
        return function(code, reason) {
          return console.log("Websocket closed. Close event data:\n Code: " + (code || 'no data') + " - Reason: " + (reason || 'no data'));
        };
      })(this));
    };

    function WampRouter(options) {
      this.listen = __bind(this.listen, this);
      this._webSocketHandler = __bind(this._webSocketHandler, this);
      this._options = options || {};
      this.roles = this._options.roles || {
        broker: {},
        dealer: {}
      };
      this.nextSessionId = genId();
      this.realms = {};
      this.webSocketServer = ws.createWebSocketServer(this._webSocketHandler);
    }

    WampRouter.prototype.listen = function(port, host, route) {
      if (host == null) {
        host = '0.0.0.0';
      }
      if (route == null) {
        route = '/wamp';
      }
      return this.webSocketServer.listen(port, host, route);
    };

    return WampRouter;

  })(events.EventEmitter);

  createWampRouter = function() {
    return new WampRouter;
  };

  test = function() {
    var wampRouter;
    wampRouter = createWampRouter();
    wampRouter.listen(8000, '0.0.0.0', '/');
    return console.log("WAMP Router listening on port 8000");
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = {
      MESSAGE_TYPES: MESSAGE_TYPES,
      TRANSPORT_TYPES: TRANSPORT_TYPES,
      WampPeer: WampPeer,
      WampClient: WampClient,
      WampRouter: WampRouter,
      createWampRouter: createWampRouter
    };
  }

  if (!(typeof module !== "undefined" && module !== null ? module.parent : void 0)) {
    test();
  }

}).call(this);
