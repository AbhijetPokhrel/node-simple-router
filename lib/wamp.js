// Generated by CoffeeScript 1.7.1
(function() {
  var MAX_ID, MESSAGE_TYPES, TRANSPORT_TYPES, WampPeer, WampRouter, WampSession, events, genId, isValidURI, net, randomNum, test, util, ws,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  events = require('events');

  util = require('util');

  net = require('net');

  ws = require('./ws');

  MESSAGE_TYPES = {
    HELLO: 1,
    WELCOME: 2,
    ABORT: 3,
    CHALLENGE: 4,
    AUTHENTICATE: 5,
    GOODBYE: 6,
    HEARTBEAT: 7,
    ERROR: 8,
    PUBLISH: 16,
    PUBLISHED: 17,
    SUBSCRIBE: 32,
    SUBSCRIBED: 33,
    UNSUBSCRIBE: 34,
    UNSUBSCRIBED: 35,
    EVENT: 36,
    CALL: 48,
    CANCEL: 49,
    RESULT: 50,
    REGISTER: 64,
    REGISTERED: 65,
    UNREGISTER: 66,
    UNREGISTERED: 67,
    INVOCATION: 68,
    INTERRUPT: 69,
    YIELD: 70
  };

  TRANSPORT_TYPES = {
    DIRECT: 1,
    WEBSOCKET: 2,
    UNIXSOCKET: 3
  };

  MAX_ID = Math.pow(2, 53);

  isValidURI = function(uri_string) {
    return !!uri_string.match(/^(([0-9a-z_]{2,}\.)|\.)*([0-9a-z_]{2,})?$/);
  };

  randomNum = function(len) {
    var n;
    return parseInt(((function() {
      var _i, _results;
      _results = [];
      for (n = _i = 1; 1 <= len ? _i <= len : _i >= len; n = 1 <= len ? ++_i : --_i) {
        _results.push((Math.floor(Math.random() * 10)).toString());
      }
      return _results;
    })()).join(''));
  };

  genId = function() {
    return randomNum(15);
  };

  WampSession = (function(_super) {
    __extends(WampSession, _super);

    function WampSession(id, options) {
      var key, val, _ref;
      this.id = id;
      this._options = options || {};
      _ref = this._options;
      for (key in _ref) {
        val = _ref[key];
        this[key] = val;
      }
      this.nextId = 1;
    }

    return WampSession;

  })(events.EventEmitter);

  WampPeer = (function(_super) {
    __extends(WampPeer, _super);

    function WampPeer(parent, transport, roles) {
      this.parent = parent;
      this.transport = transport;
      this.roles = roles;
      this.processMessage = __bind(this.processMessage, this);
      this.sendMessage = __bind(this.sendMessage, this);
      this.isClosed = false;
      this.transport.on('close', (function(_this) {
        return function(code) {
          return _this.isClosed = true;
        };
      })(this));
    }

    WampPeer.prototype.sendMessage = function(message) {
      if (!this.isClosed) {
        return this.transport.send(message);
      }
    };

    WampPeer.prototype.processMessage = function(message) {
      var ArgumentsKwDict, ArgumentsList, OptionsDict, ProcedureUri, PublicationId, RegistrationId, RequestId, SubscriptionId, TopicUri, arr, callee_session, callee_sessionId, caller_session, caller_sessionId, code, details, index, invocation, invocation_message, key, msgArray, proc, realm, registrationId, resp, result_message, session, subscription, suscription, topic, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref10, _ref11, _ref12, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      if (this.isClosed) {
        return;
      }
      arr = JSON.parse(message);
      code = arr[0];
      if (code !== MESSAGE_TYPES.HELLO && code !== MESSAGE_TYPES.WELCOME) {
        if (!this.session) {
          return;
        }
      }
      switch (code) {
        case MESSAGE_TYPES.HELLO:
          console.log("Router received HELLO message");
          _ref = arr.slice(1), realm = _ref[0], details = _ref[1];
          this.session = new WampSession(this.parent.nextSessionId, {
            peer: this,
            realm: realm,
            details: details
          });
          if (!(realm in this.parent.realms)) {
            this.parent.realms[realm] = {
              sessions: [],
              registered_procedures: [],
              invocations: [],
              subscriptions: {}
            };
          }
          this.parent.realms[realm].sessions.push(this.session);
          console.log("@realms[" + realm + "].sessions.length: %d", this.parent.realms[realm].sessions.length);
          this.sendMessage(JSON.stringify([
            MESSAGE_TYPES.WELCOME, this.parent.nextSessionId, {
              roles: this.roles
            }
          ]));
          console.log("Router sent WELCOME message to " + this.parent.nextSessionId);
          return this.parent.nextSessionId += 1;
        case MESSAGE_TYPES.WELCOME:
          return console.log("Received Welcome Message");
        case MESSAGE_TYPES.ABORT:
          return console.log("Received Abort Message");
        case MESSAGE_TYPES.CHALLENGE:
          return console.log("Received Challenge Message");
        case MESSAGE_TYPES.AUTHENTICATE:
          return console.log("Received Authenticate Message");
        case MESSAGE_TYPES.GOODBYE:
          return this.sendMessage(message);
        case MESSAGE_TYPES.HEARTBEAT:
          return console.log("Received HeartBeat Message");
        case MESSAGE_TYPES.PUBLISH:
          _ref1 = arr.slice(1), RequestId = _ref1[0], OptionsDict = _ref1[1], TopicUri = _ref1[2], ArgumentsList = _ref1[3], ArgumentsKwDict = _ref1[4];
          PublicationId = this.session.nextId;
          this.session.nextId += 1;
          topic = this.parent.realms[this.session.realm].subscriptions[TopicUri];
          if (topic) {
            for (_i = 0, _len = topic.length; _i < _len; _i++) {
              suscription = topic[_i];
              _ref2 = this.parent.realms[this.session.realm].sessions;
              for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                session = _ref2[_j];
                if (session.id === suscription.sessionId) {
                  msgArray = [MESSAGE_TYPES.EVENT, suscription.SubscriptionId, PublicationId, OptionsDict];
                  if (ArgumentsList) {
                    msgArray.push(ArgumentsList);
                  }
                  if (ArgumentsKwDict) {
                    msgArray.push(ArgumentsKwDict);
                  }
                  session.peer.sendMessage(JSON.stringify(msgArray));
                  break;
                }
              }
            }
          }
          if (OptionsDict.acknowledge) {
            return this.sendMessage(JSON.stringify([MESSAGE_TYPES.PUBLISHED, RequestId, PublicationId]));
          }
          break;
        case MESSAGE_TYPES.PUBLISHED:
          return console.log("Received Published Message");
        case MESSAGE_TYPES.SUBSCRIBE:
          console.log("Received subscribe message from session " + this.session.id);
          _ref3 = arr.slice(1), RequestId = _ref3[0], OptionsDict = _ref3[1], TopicUri = _ref3[2];
          SubscriptionId = this.session.nextId;
          this.session.nextId += 1;
          if (!this.parent.realms[this.session.realm].subscriptions[TopicUri]) {
            this.parent.realms[this.session.realm].subscriptions[TopicUri] = [];
          }
          this.parent.realms[this.session.realm].subscriptions[TopicUri].push({
            sessionId: this.session.id,
            SubscriptionId: SubscriptionId,
            OptionsDict: OptionsDict
          });
          resp = [MESSAGE_TYPES.SUBSCRIBED, RequestId, SubscriptionId];
          this.sendMessage(JSON.stringify(resp));
          return console.log("Registered subscription for " + TopicUri + " in realm " + this.session.realm);
        case MESSAGE_TYPES.SUBSCRIBED:
          return console.log("Received Subscribed Message");
        case MESSAGE_TYPES.UNSUBSCRIBE:
          _ref4 = arr.slice(1), RequestId = _ref4[0], SubscriptionId = _ref4[1];
          console.log("Received unsubscribe message from session " + this.session.id + " with requestId: " + RequestId + " and subscriptionId: " + SubscriptionId);
          _ref5 = this.parent.realms[this.session.realm].subscriptions;
          for (key in _ref5) {
            topic = _ref5[key];
            for (index = _k = 0, _len2 = topic.length; _k < _len2; index = ++_k) {
              subscription = topic[index];
              if ((subscription.SubscriptionId === SubscriptionId) && (subscription.sessionId === this.session.id)) {
                console.log("Found subscription to erase at index " + index + ". Going to do it for request: " + RequestId);
                topic.splice(index, 1);
                return this.sendMessage(JSON.stringify([MESSAGE_TYPES.UNSUBSCRIBED, RequestId]));
              }
            }
          }
          console.log("Did not find a subscription to erase. Sending error message: 'wamp.error.no_such_subscription'");
          return this.sendMessage(JSON.stringify([MESSAGE_TYPES.ERROR, MESSAGE_TYPES.UNSUBSCRIBE, RequestId, {}, "wamp.error.no_such_subscription"]));
        case MESSAGE_TYPES.UNSUBSCRIBED:
          return console.log("Received Unsubscribed Message");
        case MESSAGE_TYPES.EVENT:
          return console.log("Received Event Message");
        case MESSAGE_TYPES.CALL:
          console.log("Received Call Message from session " + this.session.id + " with request Id = " + arr[1]);
          _ref6 = arr.slice(1), RequestId = _ref6[0], OptionsDict = _ref6[1], ProcedureUri = _ref6[2], ArgumentsList = _ref6[3], ArgumentsKwDict = _ref6[4];
          _ref7 = this.parent.realms[this.session.realm].registered_procedures;
          for (_l = 0, _len3 = _ref7.length; _l < _len3; _l++) {
            proc = _ref7[_l];
            if (proc.ProcedureUri === ProcedureUri) {
              callee_sessionId = proc.sessionId;
              registrationId = proc.RegistrationId;
              _ref8 = this.parent.realms[this.session.realm].sessions;
              for (_m = 0, _len4 = _ref8.length; _m < _len4; _m++) {
                session = _ref8[_m];
                if (session.id === callee_sessionId) {
                  callee_session = session;
                  invocation_message = [MESSAGE_TYPES.INVOCATION, RequestId, registrationId, OptionsDict, ArgumentsList || [], ArgumentsKwDict || {}];
                  this.parent.realms[this.session.realm].invocations.push({
                    sessionId: this.session.id,
                    requestId: RequestId
                  });
                  return callee_session.peer.sendMessage(JSON.stringify(invocation_message));
                }
              }
            }
          }
          break;
        case MESSAGE_TYPES.CANCEL:
          return console.log("Received Cancel Message");
        case MESSAGE_TYPES.RESULT:
          return console.log("Received Result Message");
        case MESSAGE_TYPES.REGISTER:
          console.log("Received register message from session " + this.session.id);
          _ref9 = arr.slice(1), RequestId = _ref9[0], OptionsDict = _ref9[1], ProcedureUri = _ref9[2];
          RegistrationId = this.session.nextId;
          this.session.nextId += 1;
          this.parent.realms[this.session.realm].registered_procedures.push({
            sessionId: this.session.id,
            RegistrationId: RegistrationId,
            OptionsDict: OptionsDict,
            ProcedureUri: ProcedureUri
          });
          resp = [MESSAGE_TYPES.REGISTERED, RequestId, RegistrationId];
          this.sendMessage(JSON.stringify(resp));
          return console.log("Registered procedure " + ProcedureUri + " in realm " + this.session.realm);
        case MESSAGE_TYPES.REGISTERED:
          return console.log("Received Registered Message");
        case MESSAGE_TYPES.UNREGISTER:
          return console.log("Received Unregister Message");
        case MESSAGE_TYPES.UNREGISTERED:
          return console.log("Received Unregistered Message");
        case MESSAGE_TYPES.INVOCATION:
          return console.log("Received Invocation Message");
        case MESSAGE_TYPES.INTERRUPT:
          return console.log("Received Interrupt Message");
        case MESSAGE_TYPES.YIELD:
          console.log("Received Yield Message from session " + this.session.id);
          _ref10 = arr.slice(1), RequestId = _ref10[0], OptionsDict = _ref10[1], ArgumentsList = _ref10[2], ArgumentsKwDict = _ref10[3];
          console.log("Yield message data\nRequestId: " + RequestId);
          console.log("OptionsDict: %j", OptionsDict);
          console.log("ArgumentsList: " + ArgumentsList);
          console.log("ArgumentsKwDict: " + ArgumentsKwDict);
          _ref11 = this.parent.realms[this.session.realm].invocations;
          for (_n = 0, _len5 = _ref11.length; _n < _len5; _n++) {
            invocation = _ref11[_n];
            if (invocation.requestId === RequestId) {
              caller_sessionId = invocation.sessionId;
              _ref12 = this.parent.realms[this.session.realm].sessions;
              for (_o = 0, _len6 = _ref12.length; _o < _len6; _o++) {
                session = _ref12[_o];
                if (session.id === caller_sessionId) {
                  caller_session = session;
                  result_message = [MESSAGE_TYPES.RESULT, RequestId, OptionsDict, ArgumentsList || [], ArgumentsKwDict || {}];
                  console.log("Sending results to session " + caller_session.id + " corresponding to request Id: " + RequestId);
                  return caller_session.peer.sendMessage(JSON.stringify(result_message));
                }
              }
            }
          }
          break;
        default:
          return console.log("Unknown code received.");
      }
    };

    return WampPeer;

  })(events.EventEmitter);

  WampRouter = (function(_super) {
    __extends(WampRouter, _super);

    WampRouter.prototype._webSocketHandler = function(websocket) {
      websocket.peer = new WampPeer(this, websocket, this.roles);
      websocket.on('open', (function(_this) {
        return function() {
          return console.log("WebSocket opened");
        };
      })(this));
      websocket.on('data', (function(_this) {
        return function(opcode, data) {
          return websocket.peer.processMessage(data);
        };
      })(this));
      return websocket.on('close', (function(_this) {
        return function(wasClean, code, reason) {
          return console.log("Websocket closed. Close event data:\n wasClean: " + (wasClean || 'no data') + " - Code: " + (code || 'no data') + " - Reason: " + (reason || 'no data'));
        };
      })(this));
    };

    function WampRouter(options) {
      this._webSocketHandler = __bind(this._webSocketHandler, this);
      this._options = options || {};
      this._wsPort = this._options.wsPort || 8000;
      this._wsAddress = this._options.wsAddress || '0.0.0.0';
      this._wsRoute = this._options.wsRoute || "/wamp";
      this.roles = this._options.roles || {
        broker: {},
        dealer: {}
      };
      this.nextSessionId = genId();
      this.realms = {};
      this.webSocketServer = ws.createWebSocketServer(this._webSocketHandler);
      if (typeof this._wsPort === 'object') {
        this.webSocketServer.listen(this._wsPort, null, this._wsRoute);
      } else {
        this.webSocketServer.listen(this._wsPort, this._wsAddress, this._wsRoute);
      }
    }

    return WampRouter;

  })(events.EventEmitter);

  test = function() {
    var wampRouter;
    wampRouter = new WampRouter({
      wsRoute: '/'
    });
    return console.log("WAMP Router listening on port 8000");
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = {
      MESSAGE_TYPES: MESSAGE_TYPES,
      TRANSPORT_TYPES: TRANSPORT_TYPES,
      WampSession: WampSession,
      WampPeer: WampPeer,
      WampRouter: WampRouter
    };
  }

  if (!(typeof module !== "undefined" && module !== null ? module.parent : void 0)) {
    test();
  }

}).call(this);
