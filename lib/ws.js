// Generated by CoffeeScript 1.7.1
(function() {
  var KEY_SUFFIX, WebSocketConnection, WebSocketServer, createWebSocketServer, crypto, encodeMessage, events, exports, hashWebSocketKey, http, lowerObjKeys, opcodes, test, unmask, util;

  events = require("events");

  http = require("http");

  crypto = require("crypto");

  util = require("util");

  opcodes = {
    TEXT: 1,
    BINARY: 2,
    CLOSE: 8,
    PING: 9,
    PONG: 10
  };

  KEY_SUFFIX = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";

  lowerObjKeys = function(obj) {
    var index, key, keys, lkeys, resp, _i, _len;
    keys = (function() {
      var _results;
      _results = [];
      for (key in obj) {
        _results.push(key);
      }
      return _results;
    })();
    lkeys = keys.map(function(key) {
      return key.toLowerCase();
    });
    resp = {};
    for (index = _i = 0, _len = keys.length; _i < _len; index = ++_i) {
      key = keys[index];
      resp[lkeys[index]] = obj[keys[index]];
    }
    return resp;
  };

  hashWebSocketKey = function(key) {
    var sha1;
    sha1 = crypto.createHash("sha1");
    sha1.update(key + KEY_SUFFIX, "ascii");
    return sha1.digest("base64");
  };

  unmask = function(maskBytes, data) {
    var i, payload;
    payload = new Buffer(data.length);
    i = 0;
    while (i < data.length) {
      payload[i] = maskBytes[i % 4] ^ data[i];
      i++;
    }
    return payload;
  };

  encodeMessage = function(opcode, payload) {
    var b1, b2, buf, length;
    buf = void 0;
    b1 = 0x80 | opcode;
    b2 = 0;
    length = payload.length;
    if (length < 126) {
      buf = new Buffer(payload.length + 2 + 0);
      b2 |= length;
      buf.writeUInt8(b1, 0);
      buf.writeUInt8(b2, 1);
      payload.copy(buf, 2);
    } else if (length < (1 << 16)) {
      buf = new Buffer(payload.length + 2 + 2);
      b2 |= 126;
      buf.writeUInt8(b1, 0);
      buf.writeUInt8(b2, 1);
      buf.writeUInt16BE(length, 2);
      payload.copy(buf, 4);
    } else {
      buf = new Buffer(payload.length + 2 + 8);
      b2 |= 127;
      buf.writeUInt8(b1, 0);
      buf.writeUInt8(b2, 1);
      buf.writeUInt32BE(0, 2);
      buf.writeUInt32BE(length, 6);
      payload.copy(buf, 10);
    }
    return buf;
  };

  WebSocketConnection = function(req, socket, upgradeHead) {
    var key, self;
    self = this;
    key = hashWebSocketKey(lowerObjKeys(req.headers)["sec-websocket-key"]);
    socket.write("HTTP/1.1 101 Web Socket Protocol Handshake\r\n" + "Upgrade: WebSocket\r\n" + "Connection: Upgrade\r\n" + "sec-websocket-accept: " + key + "\r\n\r\n");
    socket.on("data", function(buf) {
      self.buffer = Buffer.concat([self.buffer, buf]);
      while (self._processBuffer()) {
        continue;
      }
    });
    socket.on("close", function(had_error) {
      if (!self.closed) {
        self.emit("close", 1006);
        self.closed = true;
      }
    });
    this.request = req;
    this.socket = socket;
    this.buffer = new Buffer(0);
    this.closed = false;
    this.currentRoundTrip = 0;
  };

  util.inherits(WebSocketConnection, events.EventEmitter);

  Object.defineProperty(WebSocketConnection.prototype, 'readyState', {
    get: function() {
      return this.socket.readyState;
    }
  });

  WebSocketConnection.prototype.ping = function() {
    return this._doSend(opcodes.PING, new Buffer(new Date().getTime().toString()));
  };

  WebSocketConnection.prototype.send = function(obj) {
    var e, opcode, payload;
    opcode = void 0;
    payload = void 0;
    if (Buffer.isBuffer(obj)) {
      opcode = opcodes.BINARY;
      payload = obj;
    } else if (typeof obj === "string") {
      opcode = opcodes.TEXT;
      payload = new Buffer(obj, "utf8");
    } else {
      try {
        obj = JSON.stringify(obj);
        opcode = opcodes.TEXT;
        payload = new Buffer(obj, "utf8");
      } catch (_error) {
        e = _error;
        throw new Error("Cannot send object. Must be string or Buffer");
      }
    }
    this._doSend(opcode, payload);
  };

  WebSocketConnection.prototype.close = function(code, reason) {
    var buffer, opcode;
    opcode = opcodes.CLOSE;
    buffer = void 0;
    if (code) {
      buffer = new Buffer(Buffer.byteLength(reason) + 2);
      buffer.writeUInt16BE(code, 0);
      buffer.write(reason, 2);
    } else {
      buffer = new Buffer(0);
    }
    this._doSend(opcode, buffer);
    this.closed = true;
  };

  WebSocketConnection.prototype._processBuffer = function() {
    var b1, b2, buf, fin, highBits, idx, length, mask, maskBytes, opcode, payload;
    buf = this.buffer;
    if (buf.length < 2) {
      return;
    }
    idx = 2;
    b1 = buf.readUInt8(0);
    fin = b1 & 0x80;
    opcode = b1 & 0x0f;
    b2 = buf.readUInt8(1);
    mask = b2 & 0x80;
    length = b2 & 0x7f;
    if (length > 125) {
      if (buf.length < 8) {
        return;
      }
      if (length === 126) {
        length = buf.readUInt16BE(2);
        idx += 2;
      } else if (length === 127) {
        highBits = buf.readUInt32BE(2);
        if (highBits !== 0) {
          this.close(1009, "");
        }
        length = buf.readUInt32BE(6);
        idx += 8;
      }
    }
    if (buf.length < idx + 4 + length) {
      return;
    }
    maskBytes = buf.slice(idx, idx + 4);
    idx += 4;
    payload = buf.slice(idx, idx + length);
    payload = unmask(maskBytes, payload);
    this._handleFrame(opcode, payload);
    this.buffer = buf.slice(idx + length);
    return true;
  };

  WebSocketConnection.prototype._handleFrame = function(opcode, buffer) {
    var code, payload, ping_millis, pong_millis, reason;
    payload = void 0;
    switch (opcode) {
      case opcodes.TEXT:
        payload = buffer.toString("utf8");
        this.emit("data", opcode, payload);
        break;
      case opcodes.BINARY:
        payload = buffer;
        this.emit("data", opcode, payload);
        break;
      case opcodes.PING:
        this._doSend(opcodes.PONG, buffer);
        break;
      case opcodes.PONG:
        pong_millis = new Date().getTime();
        ping_millis = parseInt(buffer.toString('utf8'));
        this.currentRoundTrip = (pong_millis - ping_millis) / 1000;
        this.emit("heartbeat", this.currentRoundTrip, pong_millis);
        break;
      case opcodes.CLOSE:
        code = void 0;
        reason = void 0;
        if (buffer.length >= 2) {
          code = buffer.readUInt16BE(0);
          reason = buffer.toString("utf8", 2);
        }
        this.close(code, reason);
        this.emit("close", code, reason);
        break;
      default:
        this.close(1002, "unknown opcode");
        this.emit("close", 1002, "unknown opcode");
    }
  };

  WebSocketConnection.prototype._doSend = function(opcode, payload) {
    this.socket.write(encodeMessage(opcode, payload));
  };

  WebSocketServer = function(handler) {
    if (handler && handler.constructor.name === "Function") {
      this.connectionHandler = handler;
    } else {
      throw new Error("Must provide a socket handler function to instantiate a WebSocketServer");
    }
  };

  WebSocketServer.prototype.listen = function(port, host) {
    var self, srv;
    srv = void 0;
    self = this;
    switch (port.constructor.name) {
      case "Server":
        srv = port;
        break;
      case "String":
        srv = http.createServer(function(request, response) {
          response.end("websocket server");
        });
        srv.listen(port);
        break;
      case "Number":
        srv = http.createServer(function(request, response) {
          response.end("websocket server");
        });
        srv.listen(port, (host ? host : "0.0.0.0"));
        break;
      default:
        if (port._handle) {
          srv = port;
        } else {
          throw new TypeError("WebSocketServer only listens on something that has a _handle.");
        }
    }
    srv.on("upgrade", function(req, socket, upgradeHead) {
      var ws;
      ws = new WebSocketConnection(req, socket, upgradeHead);
      self.connectionHandler(ws);
      setTimeout((function() {
        return setInterval((function() {
          return ws.ping();
        }), 2000);
      }), 1000);
    });
  };

  createWebSocketServer = function(handler) {
    return new WebSocketServer(handler);
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = exports = {
      createWebSocketServer: createWebSocketServer,
      WebSocketServer: WebSocketServer,
      WebSocketConnection: WebSocketConnection,
      opcodes: opcodes
    };
  }

  test = function() {
    var reverseServer;
    reverseServer = createWebSocketServer(function(sock) {
      sock.on("data", function(opcode, data) {
        sock.send(data.split("").reverse().join(""));
      });
    });
    reverseServer.listen(8000);
    console.log("Reverse WebSocket Server listening on port 8000");
  };

  if (!(typeof module !== "undefined" && module !== null ? module.parent : void 0)) {
    test();
  }

}).call(this);
