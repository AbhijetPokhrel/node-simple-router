<div xmlns="http://www.w3.org/1999/html">
  <div class="page-header">
    <h1>Documents</h1>
  </div>
  <div class="panel panel-primary">
     <div class="panel-heading">
         <h3 class="panel-title">Rationale</h3>
     </div>
     <div class="panel-body">
         <p>Routing, in web app parlance, is about defining what code to execute when a given URL is invoked.</p>
         <p>
             NSR takes care of the necessary plumbing to make that happen,
             freeing the programmer of the cumbersome details, allowing her to focus on the problem domain.
         </p>
     </div>
  </div>

    <div class="panel panel-primary">
        <div class="panel-heading">
            <h3 class="panel-title">Options</h3>
        </div>
        <div class="panel-body">
            <p>NSR sticks to some conventions ("public" as directory name for static assets, etc),</p>
            <p>which the programmer can override when instantiating the router, for instance:</p>
            <p><pre><code class="js">var router = new Router({static_route: __dirname + "/static"});</code></pre></p>
            <p>to change usage of the default "public" directory for static resources</p>
            <p>List of default options:</p>
            <p>
                <pre><code class="js">
                logging: true<br/>
                log: console.log<br/>
                static_route: "#{process.cwd()}/public"<br/>
                serve_static: true<br/>
                list_dir: true<br/>
                default_home: ['index.html', 'index.htm', 'default.htm']<br/>
                cgi_dir: "cgi-bin"<br/>
                serve_cgi: true<br/>
                serve_php: true<br/>
                php_cgi: "php-cgi"<br/>
                served_by: 'Node Simple Router'<br/>
                software_name: 'node-simple-router'<br/>
                admin_user: 'admin'<br/>
                admin_pwd: 'admin'<br/>
                </code></pre>
            </p>
            <p>Most of them are self explanatory, but some deserve further comments,</p>
            <p>which will be added on doc completion.</p>
        </div>
    </div>

    <div class="panel panel-primary">
        <div class="panel-heading">
            <h3 class="panel-title">Router API</h3>
        </div>
        <div class="panel-body">
            <p>Router object supports the following methods</p>
            <p>
                <ul class="list-group">
                    <li class="list-group-item">
                        <h4><dfn>get</dfn></h4>
                        <pre><em>Usage:</em><br/><code class="js">router.get('/users/:id', function(request, response) {
                        response.end("User: " + getUserById(request.params.id).fullName);});</code></pre>
                    </li>
                    <li class="list-group-item">
                        <h4><dfn>post</dfn></h4>
                        <pre><em>Usage:</em><br/><code class="js">router.post('/users', function(request, response) {
                        insertUser(request.post.user, function(new_user_id) {
                          request.post.user.id = new_user_id;
                          response.end(JSON.stringify(request.post.user);});
                        });</code></pre>
                        <h4>Handling file uploads</h4>
                        <p>
                            <span style="color: red;">NSR</span> handles 'multipart/form-data' out of the box.
                            You just need to be aware of the conventions involved, which are depicted in the
                            following usage example.
                        </p>
                        <p>
                            <pre><em>Usage:</em><br/>
                              <code class="js">
                                  router.post('/upload_handler', function(request, response) {
                                      if (request.post['multipart-data']) {
                                        response.write("Multipart Data/n");
                                        for (var index in request.post['multipart-data']) {
                                          if (request.post['multipart-data'][index].fileName) {
                                            var fullname = __dirname + "/public/uploads/" + request.post['multipart-data'][index].fileName;
                                            if (request.post['multipart-data'][index].contentType.indexOf('text') >= 0)
                                                fs.writeFileSync(fullname, part.fileData);
                                            else
                                                fs.writeFileSync(fullname, part.fileData, 'binary');
                                            response.end("File " + request.post['multipart-data'][index].fileName + "successfully saved.");
                                            break;
                                          }
                                      }
                                      else
                                        response.end("Sorry, no multipart data, so no upload...\n");
                                  });
                              </code>
                            </pre>
                        </p>
                    </li>
                    <li class="list-group-item">
                        <h4><dfn>put</dfn></h4>
                                <pre><em>Usage:</em><br/><code class="js">router.put('/users', function(request, response) {
                                    updateUser(request.post.user, function(updated_user_id) {
                                    response.end(updated_user_id);})
                                    });</code></pre>
                    </li>
                    <li class="list-group-item">
                        <h4><dfn>patch</dfn></h4>&nbsp;&nbsp;&nbsp;A variant for PUT
                                <pre><em>Usage:</em><br/><code class="js">router.patch('/users', function(request, response) {
                                    updateUser(request.post.user, function(updated_user_id) {
                                    response.end(updated_user_id);});
                                    });</code></pre>
                    </li>
                    <li class="list-group-item">
                        <h4><dfn>delete</dfn></h4>&nbsp;&nbsp;&nbsp;
                                <pre><em>Usage:</em><br/><code class="js">router.delete('/users', function(request, response) {
                                    deleteUser(request.post.user_id, function(user_id) {
                                    response.end(user_id);});
                                    });</code></pre>
                    </li>
                    <li class="list-group-item">
                        <h4><dfn>any</dfn></h4>&nbsp;&nbsp;&nbsp;To be used when the request method is not known in advance. Sort of "catch all"
                        <pre><em>Usage:</em><br/><code class="js">router.any('/users', function(request, response) {
                            response.end("User: " + getUserById(request.body.user_id).fullName);}); // Observe the usage of 'request.body' as the union of 'request.get' and 'request.post'</code></pre>
                    </li>
                    <li class="list-divider">

                    </li>
                    <li class="list-group-item">
                        <div class="list-group-item-heading">
                            <h4><dfn>Complementary methods</dfn></h4>
                        </div>
                        <div class="list-group-item-text">
                            Up to here, all the enumerated methods are directly related to <span style="color: red;">NSR</span> primary activity: routing.
                            They are what you will use 90% of the time.<br/>What follows are method loosely related to
                            routing activity, but are the ones that give <span style="color: red;">NSR</span> some of its
                            distinctiveness.
                        </div>
                    </li>
                    <li class="list-group-item">
                        <h4><dfn>proxy_pass</dfn></h4>&nbsp;&nbsp;&nbsp;To deliver to the client the contents of an url from another server
                        <pre><em>Usage:</em><br/><code class="js">router.get('/whatismyip', function(request, response) {
                            router.proxy_pass('http://testing.savos.ods.org/wimi', response);});</code>
                         </pre>
                    </li>
                    <li class="list-group-item">
                        <div class="list-group-item-heading">
                            <p><h4><dfn><abbr title="Common Gateway Interface">cgi</abbr></dfn></h4>&nbsp;&nbsp;&nbsp;To pass the client the results of an external CGI program.</p>
                        </div>
                        <div class="list-group-item-text">
                            <p>
                                This one deserves an additional comment on its usefulness. While some - many perhaps - would argue
                                that CGI doesn't make any sense from a Node.js development perspective, I still it's a worthy inclusion
                                for a couple of reasons
                                  <ul>
                                    <li>First of all, you may have a legacy CGI module that you want/need to use in your brand new Node.js server - would you rewrite, for instance, Crafty, the chess engine, in Node? -</li>
                                    <li>Writing programs that can talk to each other through standard means (stdin, stdout) has passed the test of time, and I think it has it niche even in the web server world.</li>
                                    <li>If performance is a concern - and it should be - the present considerations still stand for the next item: SCGI, which NSR also supports. But there would not have been SCGI without CGI</li>
                                    <li>Last but not least, CGI support makes the same sense in the context of a Node.js web server thant it does in Nginx, Apache, etc.. I'm not aware of anybody suggestiong CGI support should be dropped from any of them.</li>
                                  </ul>
                            </p>
                            <pre>
                                <em>Usage:</em><br/>
                                <samp>
                                    By default, any static resource having a path that includes the router option 'cgi-dir'
                                    (which defaults to "cgi-bin") will be treated by <span style="color: red;">NSR</span>
                                    as a cgi program, provided the router option 'serve_cgi' is true.<br/>
                                    For example, the uri: <code class='js'>/cgi-bin/hello.py</code> will be handled as a CGI program.<br/>
                                    On the other hand, you can invoke directly the cgi method of the router, like so:<br/>
                                    <code class="js">router.cgi('/hidden-cgi-dir/mycgi.rb', request, response);</code><br/>
                                    Nevertheless, such way of using it is discouraged as it does not follow CGI standard
                                    guidelines.
                                </samp>
                             </pre>
                        </div>
                    </li>
                    <li class="list-group-item">
                        <div class="list-group-item-heading">
                            <h4><dfn>scgi_pass</dfn></h4>
                            <p>To pass the client the results of an external program running under the <a target="_blank" href="http://en.wikipedia.org/wiki/SCGI">SCGI</a> protocol.</p>
                        </div>
                        <div class="list-group-item-text">
                           <p>Same considerations as those pertaining to CGI, with the added benefit of not having to spawn a new process each time.</p>
                           <p>Why SCGI and not <dfn title="Fast CGI">FCGI</dfn>? Well, SCGI protocol was far easier to implement, and I really couldn't find significant performance differences between the two. FCGI may be implenented in future versions.</p>
                           <p>
                               <pre>
                                  <em>Usage:</em><br/>
                                  <code class="js">
                                  //Example SCGI invocation. Output will be provided by a SCGI process listening on tcp port 26000.
                                  router.post("/scgi", function(request, response) {
                                    router.scgi_pass(26000, request, response);
                                  }
                                  </code><br/>
                                  The first parameter for scgi_pass is the port number (for tcp sockets)
                                  or the socket name (for unix sockets) at which the SCGI process is listening.
                               </pre>
                           </p>
                        </div>
                    </li>
                </ul>
            </p>
        </div>
    </div>

</div>
